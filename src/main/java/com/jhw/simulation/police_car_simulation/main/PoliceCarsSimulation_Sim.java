package com.jhw.simulation.police_car_simulation.main;

import com.jhw.simulation.police_car_simulation.utils.Utility_Class;
import com.jhw.simulation.police_car_simulation.utils.XMLoader_Class;
import com.jhw.simulation.police_car_simulation.inner.AreaColor_Class;
import com.jhw.simulation.police_car_simulation.inner.XMLInfo_Class;
import com.jhw.simulation.police_car_simulation.inner.PatrolStateType_Enum;
import com.jhw.simulation.police_car_simulation.agents.Emergency;
import com.jhw.simulation.police_car_simulation.agents.Patrol;
import java.util.*;
import sim.io.geo.*;
import sim.util.geo.*;
import com.vividsolutions.jts.geom.*;
import com.vividsolutions.jts.planargraph.Node;
import java.net.URL;
import sim.engine.SimState;
import sim.field.geo.GeomVectorField;
import sim.portrayal.LocationWrapper;

/**
 * Class that describe the Simulation State.
 *
 * @author Margaret Sánchez Martínez
 */
public class PoliceCarsSimulation_Sim extends SimState {

    /**
     * Field to hold the GIS information of the roads.
     */
    private final GeomVectorField roads = new GeomVectorField(SimulationMain.cfg.getDisplayWidth(), SimulationMain.cfg.getDisplayHeight());

    /**
     * Fields to hold the GIS information of the diferent areas.
     */
    private final LinkedList<GeomVectorField> areas = new LinkedList<>();

    /**
     * Fields to hold the GIS information of each patrol.
     */
    private final GeomVectorField patrols = new GeomVectorField(SimulationMain.cfg.getDisplayWidth(), SimulationMain.cfg.getDisplayHeight());

    /**
     * Map where all the patrols live.
     */
    private final HashMap<Integer, Patrol> patrolsMap = new HashMap<>();

    /**
     * Info loaded from the xml solution.
     */
    private LinkedList<XMLInfo_Class> instalationInitial = new LinkedList<>();

    /**
     * Fields to hold the GIS information of each emergency.
     */
    private final GeomVectorField emergencies = new GeomVectorField(SimulationMain.cfg.getDisplayWidth(), SimulationMain.cfg.getDisplayHeight());

    /**
     * Map where all the emergency live.
     */
    private final HashMap<Integer, Emergency> emergenciesMap = new HashMap<>();

    /**
     * Stores the roads network connections. We represent the roads as a
     * PlanarGraph, which allows easy selection of new waypoints for the
     * patrols.
     */
    private final GeomPlanarGraph network = new GeomPlanarGraph();

    /**
     * Fields to hold the GIS information of the junctions.
     */
    private final GeomVectorField junctions = new GeomVectorField();

    /**
     * Create the simulatrion state with the specific seed for the random number
     * generator.
     *
     * @param seed of the random number generator.
     * @throws Exception if the .shp files is not located.
     */
    public PoliceCarsSimulation_Sim(long seed) throws Exception {
        super(seed);
        loadGIS();
        loadXML();
        SimulationMain.cfg.adjustScreenSize(roads.MBR);
    }

    /**
     * Load the GIS information of the files.
     *
     * @throws Exception if the .shp files is not located.
     */
    private void loadGIS() throws Exception {

        String dir = SimulationMain.cfg.getUrlGIS() + "/" + SimulationMain.cfg.getUrlRoads();
        URL urlRoadsShp = new URL("file", null, dir + ".shp");
        URL urlRoadsDbf = new URL("file", null, dir + ".dbf");
        ShapeFileImporter.read(urlRoadsShp, urlRoadsDbf, roads);

        Envelope MBR = roads.getMBR();

        for (AreaColor_Class act : SimulationMain.cfg.getUrlsAreas()) {
            URL urlAuxShp = new URL("file", null, SimulationMain.cfg.getUrlGIS() + "/" + act.getArea() + ".shp");
            URL urlAuxDbf = new URL("file", null, SimulationMain.cfg.getUrlGIS() + "/" + act.getArea() + ".dbf");
            GeomVectorField aux = new GeomVectorField(SimulationMain.cfg.getDisplayWidth(), SimulationMain.cfg.getDisplayHeight());
            ShapeFileImporter.read(urlAuxShp, urlAuxDbf, aux);
            MBR.expandToInclude(aux.getMBR());
            aux.setMBR(MBR);
            areas.add(aux);
        }

        patrols.setMBR(MBR);
        emergencies.setMBR(MBR);
        junctions.setMBR(MBR);
        SimulationMain.cfg.adjustAllScales(MBR);

        network.createFromGeomField(roads);
        addIntersectionNodes(network.nodeIterator());

    }

    /**
     * Load the XML information of the file.
     *
     * @throws Exception if the .xml file is not located.
     */
    private void loadXML() throws Exception {
        URL urlXML = new URL("file", null, SimulationMain.cfg.getUrlXMLData() + "/" + SimulationMain.cfg.getUrlXMLSolution());
        XMLoader_Class xml = new XMLoader_Class(urlXML);
        instalationInitial = xml.read();
    }

    /**
     * Add to the simulation and to the patrol GeomVectorField a agent in the
     * specific road.
     *
     * @param act LocationWrapper generated by the inspector for generate the
     * agent at a specific place.
     */
    public void addPoliceCar(LocationWrapper act) {
        Patrol a = new Patrol(act, this);
        patrolsMap.put(a.getId(), a);
        patrols.addGeometry(a.getGeometry());
        schedule.scheduleRepeating(a);
        schedule.scheduleRepeating(patrols.scheduleSpatialIndexUpdater(), Integer.MAX_VALUE, 1.0);
    }

    /**
     * Add to the simulation and to the patrol GeomVectorField a agent in the
     * specific road.
     *
     * @param act LocationWrapper generated by the inspector for generate the
     * agent at a specific place.
     */
    public void addPoliceCar(XMLInfo_Class act) {
        Patrol a = new Patrol(act, this);
        patrolsMap.put(a.getId(), a);
        patrols.addGeometry(a.getGeometry());
        schedule.scheduleRepeating(a);
        schedule.scheduleRepeating(patrols.scheduleSpatialIndexUpdater(), Integer.MAX_VALUE, 1.0);
    }

    /**
     * Add to the simulation and to the emergencies GeomVectorField a agent in
     * the specific road.
     *
     * @param act LocationWrapper generated by the inspector for generate the
     * agent at a specific place.
     */
    public void addEmergency(LocationWrapper act) {
        Emergency a = new Emergency(act, this);
        a.setIncrement(100000);
        emergenciesMap.put(a.getId(), a);
        emergencies.addGeometry(a.getGeometry());
        schedule.scheduleRepeating(a);
        schedule.scheduleRepeating(emergencies.scheduleSpatialIndexUpdater(), Integer.MAX_VALUE, 1.0);
        boolean moved = movePoliceToTheEmergency(a);
        if (!moved) {
            Utility_Class.jopHelp("No hay patrullas disponibles para atender la emergencia.");
        }
    }

    /**
     * Add to the simulation and to the emergencies GeomVectorField a agent in a
     * random position of the map.
     */
    void addEmergency() {
        Emergency a = new Emergency(this);
        emergenciesMap.put(a.getId(), a);
        emergencies.addGeometry(a.getGeometry());
        schedule.scheduleRepeating(a);
        schedule.scheduleRepeating(emergencies.scheduleSpatialIndexUpdater(), Integer.MAX_VALUE, 1.0);
        boolean moved = movePoliceToTheEmergency(a);
        if (!moved) {
            Utility_Class.jopHelp("No hay patruyas disponibles para atender la emergencia.");
        }
    }

    /**
     * Star the simulation, have inside the putInitialsAgents() because it has
     * to be called after the schedule.scheduleRepeating() for the initials
     * patrols can move.
     */
    @Override
    public void start() {
        super.start();
        schedule.scheduleRepeating(patrols.scheduleSpatialIndexUpdater(), Integer.MAX_VALUE, 1.0);
        putInitialsAgents();
        schedule.scheduleRepeating(emergencies.scheduleSpatialIndexUpdater(), Integer.MAX_VALUE, 1.0);
    }

    /**
     * Add nodes corresponding to road intersections to the junctions
     * GeomVectorField.<br/>
     * Nodes will belong to a planar graph populated from LineString network.
     *
     * @param nodeIterator Points to first node
     */
    private void addIntersectionNodes(Iterator<Node> nodeIterator) {
        GeometryFactory fact = new GeometryFactory();
        Coordinate coord;
        Point point;

        while (nodeIterator.hasNext()) {
            Node node = nodeIterator.next();
            coord = node.getCoordinate();
            point = fact.createPoint(coord);
            MasonGeometry mg = new MasonGeometry(point);
            mg.isMovable = true;
            junctions.addGeometry(mg);
        }
    }

    public GeomVectorField getRoads() {
        return roads;
    }

    public GeomVectorField getJunctions() {
        return junctions;
    }

    public GeomVectorField getPatrols() {
        return patrols;
    }

    public GeomVectorField getEmergencies() {
        return emergencies;
    }

    public GeomPlanarGraph getNetwork() {
        return network;
    }

    public LinkedList<GeomVectorField> getAreas() {
        return areas;
    }

    public HashMap<Integer, Patrol> getPatrolsArr() {
        return patrolsMap;
    }

    public HashMap<Integer, Emergency> getEmergenciesArr() {
        return emergenciesMap;
    }

    /**
     * Send the closest patrol to the emergency.
     *
     * @param emer Emergency.
     * @return true if someone can atend the emergency, false otherwise.
     */
    private boolean movePoliceToTheEmergency(Emergency emer) {
        ArrayList<PatDist> arr = new ArrayList<>(patrolsMap.size());

        for (Map.Entry<Integer, Patrol> act : patrolsMap.entrySet()) {
            Patrol patrol = act.getValue();
            Point p = (Point) emer.getGeometry().geometry;
            double distPath = patrol.getPathDistance(p);
            double dist = patrol.getLinealDistance(emer.getGeometry().geometry);
            if (patrol.getAgentState() == PatrolStateType_Enum.WANDERING) {
                arr.add(new PatDist(patrol, distPath, dist));
            }
        }
        Collections.sort(arr);

        int increase = 2 * emer.getIncrement();
        for (int i = 0; i < arr.size(); i++) {
            int ofert = arr.get(i).p.getOfert();
            if (increase > -1) {
                arr.get(i).p.atendToAEmergency(emer);
            }
            increase -= ofert;
        }
        return !arr.isEmpty();
    }

    /**
     * Put the initials agent into the simulation.
     */
    private void putInitialsAgents() {
        for (XMLInfo_Class act : instalationInitial) {
            addPoliceCar(act);
        }
    }

    private class PatDist implements Comparable<PatDist> {

        Patrol p;
        double dist1;
        double dist2;

        public PatDist(Patrol p, double dist1, double dist2) {
            this.p = p;
            this.dist1 = dist1;
            this.dist2 = dist2;
        }

        @Override
        public int compareTo(PatDist o) {
            int comp = Double.compare(dist1, o.dist1);
            if (comp == 0) {
                comp = Double.compare(dist2, o.dist2);
            }
            return comp;
        }
    }
}
