package com.jhw.simulation.police_car_simulation.agents;

import com.jhw.simulation.police_car_simulation.main.SimulationMain;
import com.jhw.simulation.police_car_simulation.main.PoliceCarsSimulation_Sim;
import com.jhw.simulation.police_car_simulation.inner.XMLInfo_Class;
import com.jhw.simulation.police_car_simulation.inner.PatrolStateType_Enum;
import com.jhw.simulation.police_car_simulation.inner.EmergencyStateType_Enum;
import com.jhw.simulation.police_car_simulation.utils.AStar_Class;
import com.vividsolutions.jts.geom.*;
import com.vividsolutions.jts.linearref.LengthIndexedLine;
import com.vividsolutions.jts.planargraph.*;
import java.awt.Color;
import java.util.LinkedList;
import sim.engine.*;
import sim.portrayal.LocationWrapper;
import sim.util.Bag;
import sim.util.geo.*;

/**
 * Class that control the agent Patrol.
 *
 * @author Jesús Hernández Barrios
 */
public class Patrol implements Steppable {

    /**
     * Value at witch the color would change
     */
    public static int CHANGE_COLOR_AT = 200;

    /**
     * The PoliceCarsSimulation_Sim where the agent will live.
     */
    PoliceCarsSimulation_Sim world;

    /**
     * Unic id of the aptrol in the patrol's map
     */
    private final int id;

    /**
     * Name of the aptrol.
     */
    private final String name;

    /**
     * Value of the color that the emergency will have.
     */
    private int color;

    /**
     * State of the patrol. Start at WANDERING
     */
    private Enum agentState = PatrolStateType_Enum.WANDERING;

    /**
     * Point that denotes the actual patrol's position
     */
    private final MasonGeometry location;

    /**
     * How much to move the agent by in each step().<br/>
     * May become negative if the agent is moving from the end to the start of
     * current line.
     */
    private double moveRate = 0.000005;

    private int ofert = 20;

    /**
     * Used by agent to walk along line segment.
     */
    private LengthIndexedLine segment = null;

    /**
     * Start position of current line
     */
    private double startIndex = 0.0;

    /**
     * End position of current line
     */
    private double endIndex = 0.0;

    /**
     * current location along line
     */
    private double currentIndex = 0.0;

    //graph stuf
    /**
     * Path from the patrol actual location to the emergency location. It's
     * generated by the A* algorithm.
     */
    private LinkedList<GeomPlanarGraphDirectedEdge> pathFromHomeToWork = new LinkedList<>();

    /**
     * Home node of the agent. The starting point where the agent is placed
     */
    private Node homeNode;

    /**
     * Node where the emergency is located.
     */
    private Node emergencyNode;

    /**
     * Reference to the emergency.
     */
    private Emergency em;

    //chart stuff
    /**
     * Total dsitance covered by the agent when it atends to a emergency.
     */
    private double totalDistanceCovered = 0;

    /**
     * Next point to move in.
     */
    private final PointMoveTo pointMoveTo = new PointMoveTo();

    /**
     * Generate a patrol in the LineString contained in the object of
     * LocationWrapper. It set's name in UNKNOW.
     *
     * @param act the LocationWrapper that contain in it's object the
     * LineString.
     * @param sim PoliceCarsSimulation_Sim where the agent live.
     */
    public Patrol(LocationWrapper act, PoliceCarsSimulation_Sim sim) {
        world = sim;
        name = "UNKNOW";
        id = world.getPatrolsArr().size();

        location = new MasonGeometry((Point) act.getLocation());//initial pisition
        location.isMovable = true;
        location.addIntegerAttribute("ID", id);
        location.addAttribute("NAME", name);

        //Find the first line segment and set our position over the start coordinate.
        LineString line = (LineString) ((MasonGeometry) act.getObject()).getGeometry();
        //LineString line = (LineString) act.getObject();
        setFirstRoute(line);
    }

    /**
     * Generate a patrol in the position of the xml info
     *
     * @param info xml info where the patrol will be generated.
     * @param sim PoliceCarsSimulation_Sim where the agent live.
     */
    public Patrol(XMLInfo_Class info, PoliceCarsSimulation_Sim sim) {
        world = sim;
        name = info.getName();
        id = world.getPatrolsArr().size();

        location = new MasonGeometry(info.getPosition());//initial pisition
        location.isMovable = true;
        location.addIntegerAttribute("ID", id);
        location.addAttribute("NAME", name);

        //Find the first line segment and set our position over the start coordinate.
        LineString line = getFirstLineString(info.getPosition());
        setFirstRoute(line);
    }

    /**
     * Set the first route of the agent.
     *
     * @param line where it will be put in
     */
    private void setFirstRoute(LineString line) {
        segment = new LengthIndexedLine(line);
        startIndex = segment.getStartIndex();
        endIndex = segment.getEndIndex();

        Coordinate startCoord = segment.extractPoint(startIndex);
        homeNode = world.getNetwork().findNode(startCoord);
        currentIndex = startIndex;

        //the move to method
        pointMoveTo.setCoordinate(startCoord);
        location.getGeometry().apply(pointMoveTo);
        getGeometry().geometry.geometryChanged();
        homeNode = world.getNetwork().findNode(location.geometry.getCoordinate());
    }

    /**
     * Return geometry representing patrol location.
     *
     * @return geometry representing patrol location.
     */
    public MasonGeometry getGeometry() {
        return location;
    }

    /**
     * True if the agent has arrived at the target intersection, False
     * otherwise.
     *
     * @return true if the agent has arrived at the target intersection, False
     * otherwise.
     */
    private boolean arrived() {
        return (moveRate > 0 && currentIndex >= endIndex)
                || (moveRate < 0 && currentIndex <= startIndex);
    }

    /**
     * Move the patrol to the next LineString in the path.
     */
    private void moveToNextEdge() {
        Node currentJunction = world.getNetwork().findNode(location.getGeometry().getCoordinate());

        if (currentJunction != null) {
            GeomPlanarGraphDirectedEdge directedEdge = pathFromHomeToWork.pollFirst();//get and remove the first element
            GeomPlanarGraphEdge edge = (GeomPlanarGraphEdge) directedEdge.getEdge();
            //start moving along it
            LineString newRoute = edge.getLine();
            Point startPoint = newRoute.getStartPoint();

            if (startPoint.equalsExact(location.geometry)) {
                setNewRoute(newRoute, true);
            } else {
                setNewRoute(newRoute, false);
            }
        } else {
            System.out.println("I'am not in a junction.");
        }
    }

    /**
     * Randomly selects a path to travel.
     */
    private void findNewPath() {
        Node currentJunction = world.getNetwork().findNode(location.getGeometry().getCoordinate());

        if (currentJunction != null) {
            if (currentJunction.getCoordinate().equals2D(homeNode.getCoordinate())) {//i'm in my home, go to a random place
                int depth = world.random.nextInt(SimulationMain.cfg.getMaxDepth()) + 1;
                Node endNode = currentJunction;
                for (int i = 0; i < depth; i++) {

                    DirectedEdgeStar directedEdgeStar = endNode.getOutEdges();
                    Object[] edges = directedEdgeStar.getEdges().toArray();

                    if (edges.length > 0) {
                        // pick one randomly
                        int v = world.random.nextInt(edges.length);
                        GeomPlanarGraphDirectedEdge directedEdge = (GeomPlanarGraphDirectedEdge) edges[v];
                        endNode = directedEdge.getToNode();
                    }
                }

                findNewAStarPath(currentJunction, endNode);

            } else {//return home
                findNewAStarPath(currentJunction, homeNode);
            }
        }
    }

    /**
     * Have the agent move along new route
     *
     * @param line defining new route
     * @param start true if agent at start of line else agent placed at end
     */
    private void setNewRoute(LineString line, boolean start) {
        segment = new LengthIndexedLine(line);
        startIndex = segment.getStartIndex();
        endIndex = segment.getEndIndex();

        Coordinate startCoord;

        if (start) {
            startCoord = segment.extractPoint(startIndex);
            currentIndex = startIndex;
            moveRate = Math.abs(moveRate);
        } else {
            startCoord = segment.extractPoint(endIndex);
            currentIndex = endIndex;
            moveRate = -1 * Math.abs(moveRate); // ensure we move backward along segment
        }

        moveTo(startCoord);
    }

    /**
     * Move the agent to the given coordinates.
     *
     * @param c the coordinate to move in.
     */
    public void moveTo(Coordinate c) {
        pointMoveTo.setCoordinate(c);
        location.getGeometry().apply(pointMoveTo);
        getGeometry().geometry.geometryChanged();
    }

    /**
     * Step that execute the specific patrol behavior.
     *
     * @param state PoliceCarsSimulation_Sim where it live.
     */
    @Override
    public void step(SimState state) {
        if (em != null && em.getEmergencyState() == EmergencyStateType_Enum.COMPLETED) {
            agentState = PatrolStateType_Enum.WANDERING;
            //findNewAStarPath(emergencyNode, homeNode);
            moveWandering();
        } else if (agentState == PatrolStateType_Enum.WANDERING) {//move arbitrary
            moveWandering();
        } else if (agentState == PatrolStateType_Enum.ATENDING) {
            color++;//change color
            moveAtending();
        } else {//in emergency
            color++;
        }

    }

    /**
     * Move wandering in the street graph.<br/>
     * Move along the current LineString, if arrived to the end, select the next
     * edge path, else, find a new path to folow.
     */
    private void moveWandering() {
        // if we're not at a junction move along the current segment
        if (!arrived()) {
            moveAlongPath();
        } else {//I arrived
            if (pathFromHomeToWork.isEmpty()) {//if I don't have more path, find a new one.
                findNewPath();
            } else {//move to the next edge
                moveToNextEdge();
            }
        }
    }

    /**
     * Move atending to the emergency. Move folowin the path from the emergency
     * to the emergency.
     */
    private void moveAtending() {
        // check that we've been placed on an Edge
        if (segment == null) {
            return;
        }

        // if we're not at a junction move along the current segment
        if (!arrived()) {
            moveAlongPath();
        } else {
            if (location.getGeometry().getCoordinate().equals2D(emergencyNode.getCoordinate())) {//check if the arrived point is the work
                completeAtendingToAEmergency();
            } else {
                moveToNextEdge();
            }
        }
    }

    /**
     * The end of the emergency atend. Set up the agent state back to WANDERING,
     * report the chart info, and call the completeEmergency() method on the
     * emergency.
     */
    private void completeAtendingToAEmergency() {
        em.atend(ofert);
        if (em.getDemand() != 0) {//incomplete
            System.out.println("patrol: " + name + " atending");
        } else {//complete
            agentState = PatrolStateType_Enum.WANDERING;

            findNewAStarPath(emergencyNode, homeNode);

            //put distance covered already calculated
            SimulationMain.reportDistanceCovered(totalDistanceCovered);

            System.out.println("In place, returning home");
        }

    }

    /**
     * move agent along current line segment.
     */
    private void moveAlongPath() {
        currentIndex += moveRate;

        // Truncate movement to end of line segment
        if (moveRate < 0) { // moving from endIndex to startIndex
            if (currentIndex < startIndex) {
                currentIndex = startIndex;
            }
        } else { // moving from startIndex to endIndex
            if (currentIndex > endIndex) {
                currentIndex = endIndex;
            }
        }
        moveTo(segment.extractPoint(currentIndex));
    }

    /**
     * Atend to a emergency.<br/>
     * Find the min path ant set the patrol state to ATENDING.
     *
     * @param a Emergy to atend
     * @return true if it's possible atend it.
     */
    public boolean atendToAEmergency(Emergency a) {
        Node actualNode;
        if (moveRate > 0) {
            actualNode = world.getNetwork().findNode(segment.extractPoint(segment.getEndIndex()));
        } else {
            actualNode = world.getNetwork().findNode(segment.extractPoint(segment.getStartIndex()));
        }
        this.em = a;
        emergencyNode = world.getNetwork().findNode(em.getGeometry().geometry.getCoordinate());

        findNewAStarPath(actualNode, emergencyNode);

        if (pathFromHomeToWork.isEmpty()) {
            System.out.println("Initialization of agent failed: it is located in a part "
                    + "of the network that cannot access the given goal node");
            return false;
        }

        agentState = PatrolStateType_Enum.ATENDING;

        totalDistanceCovered = getDistanceStreetPath(pathFromHomeToWork);

        return true;
    }

    /**
     * Plots a path between the Agent's cu Node and its work Node
     */
    private void findNewAStarPath(Node from, Node to) {

        // get the home and work Nodes with which this Agent is associated
        Node currentJunction = from;
        Node destinationJunction = to;

        if (currentJunction == null) {
            return; // just a check
        }
        // find the appropriate A* path between them
        LinkedList<GeomPlanarGraphDirectedEdge> path = new AStar_Class().astarPath(currentJunction, destinationJunction);

        // if the path works, lay it in
        if (path != null && path.size() > 0) {
            pathFromHomeToWork = path;
        }
    }

    /**
     * Find the closest LineString from a point.
     *
     * @param point of the position.
     * @return
     */
    private LineString getFirstLineString(Point point) {
        Bag geom = world.getRoads().getGeometries();
        int ind = -1;
        double min = Double.MAX_VALUE;
        for (int i = 0; i < geom.size(); i++) {
            Geometry line = ((MasonGeometry) geom.get(i)).geometry;
            if (line instanceof LineString) {
                LengthIndexedLine lil = new LengthIndexedLine(line);
                Coordinate c = lil.extractPoint(lil.getStartIndex());
                double distAux = c.distance(point.getCoordinate());
                if (distAux < min) {
                    min = distAux;
                    ind = i;
                }
            }
        }
        return (LineString) ((MasonGeometry) geom.get(ind)).geometry;
    }

    /**
     * Calculate and return the distance between the agent current location and
     * a geometry.
     *
     * @param geom
     * @return
     */
    public double getLinealDistance(Geometry geom) {
        return ((Point) location.geometry).distance(geom);
    }

    /**
     * Calculate and return the distance (in meters)
     *
     * @param a
     * @return
     */
    public double getPathDistance(Point a) {
        double val = Double.MAX_VALUE;//I'm far awar until I verify the oposite
        Node actualNode;
        if (moveRate > 0) {
            actualNode = world.getNetwork().findNode(segment.extractPoint(segment.getEndIndex()));
        } else {
            actualNode = world.getNetwork().findNode(segment.extractPoint(segment.getStartIndex()));
        }
        Node destNode = world.getNetwork().findNode(a.getCoordinate());// find the appropriate A* path between them
        LinkedList<GeomPlanarGraphDirectedEdge> path = new AStar_Class().astarPath(actualNode, destNode);

        // if the path works, lay it in
        if (path != null && path.size() > 0) {
            val = getDistanceStreetPath(path);
        }

        return val;
    }

    /**
     * Get the color of the patrol, if it's state is WANDERING always return
     * BLUE, else return BLUE or RED like a real ciren.
     *
     * @return
     */
    public Color getColor() {
        if (agentState == PatrolStateType_Enum.WANDERING) {
            return Color.BLUE;
        } else {
            color++;
            color %= Patrol.CHANGE_COLOR_AT;
            if (color < Patrol.CHANGE_COLOR_AT / 2) {
                return Color.BLUE;
            } else {
                return Color.RED;
            }
        }
    }

    /**
     * Return the actual location of the patrol.
     *
     * @return the actual location of the patrol.
     */
    public MasonGeometry getLocation() {
        return location;
    }

    /**
     * Return the move rate of the patrol.
     *
     * @return the move rate of the patrol.
     */
    public double getMoveRate() {
        return moveRate;
    }

    /**
     * Return the actual segment where the agent is traveling.
     *
     * @return the actual segment where the agent is traveling.
     */
    public LengthIndexedLine getSegment() {
        return segment;
    }

    /**
     * Return the start index of the LineString.
     *
     * @return the start index of the LineString.
     */
    public double getStartIndex() {
        return startIndex;
    }

    /**
     * Return the end index of the LineString.
     *
     * @return the end index of the LineString.
     */
    public double getEndIndex() {
        return endIndex;
    }

    /**
     * Return the current index in the LineString.
     *
     * @return the current index in the LineString.
     */
    public double getCurrentIndex() {
        return currentIndex;
    }

    /**
     * Return the point move to.
     *
     * @return the point move to.
     */
    public PointMoveTo getPointMoveTo() {
        return pointMoveTo;
    }

    /**
     * Return the patrol id.
     *
     * @return the patrol id.
     */
    public int getId() {
        return id;
    }

    /**
     * Return the patrol state.
     *
     * @return the patrol state.
     */
    public Enum getAgentState() {
        return agentState;
    }

    public int getOfert() {
        return ofert;
    }

    public void setOfert(int ofert) {
        this.ofert = ofert;
    }

    /**
     * Calculate the distance (in meters) of a path.
     *
     * @param path between two node
     * @return the distance in meters
     */
    private double getDistanceStreetPath(LinkedList<GeomPlanarGraphDirectedEdge> path) {
        double dist = 0;
        //calculate distance covered
        for (GeomPlanarGraphDirectedEdge act : path) {
            GeomPlanarGraphEdge edge = (GeomPlanarGraphEdge) act.getEdge();
            LineString nextRoute = edge.getLine();
            dist += com.jhw.simulation.police_car_simulation.utils.Utility_Class.lineStringLength(nextRoute);
        }
        return dist;
    }

}
